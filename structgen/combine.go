package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"text/template"

	"github.com/Mushus/gogen/aq"
	"github.com/Mushus/gogen/goname"
	"github.com/pkg/errors"
	"golang.org/x/tools/imports"
)

type combineGenerator struct {
	gens          []templateGenerator
	params        combineGeneratorParam
	structName    string
	path          string
	genFileSuffix string
	genFilePrefix string
}

type templateGenerator interface {
	collectParams(aqi *aq.Instance, oldGeneratedCode []byte) error
	generate() ([]byte, error)
}

type combineGeneratorParam struct {
	Package string
	Imports []importParams
}

func newCombineGenerator(ts targetStruct, path string) fileGenerator {
	structName := ts.Name

	gens := []templateGenerator{}

	if ts.Construct {
		gens = append(gens, newConstructGenerator(structName))
	}

	if ts.Getter {
		gens = append(gens, newGetterGenerator(structName))
	}

	if ts.Setter {
		gens = append(gens, newSetterGenerator(structName))
	}

	if ts.List {
		gens = append(gens, newListGenerator(structName))
	}

	return &combineGenerator{
		gens:          gens,
		structName:    structName,
		path:          path,
		genFileSuffix: "_gen",
		genFilePrefix: goname.LowerSnakeCase(structName),
	}
}

func (g *combineGenerator) generatedFilePath() string {
	return filepath.Join(g.path, fmt.Sprintf("%s%s.go", g.genFilePrefix, g.genFileSuffix))
}

func (g *combineGenerator) collectParams() error {
	aqi := aq.New().MustLoadDir(*path, aq.IngoreSuffix(g.genFileSuffix))
	s := aqi.Structs().FindOne(aq.StructNameIs(g.structName))
	if !s.Exists() {
		return errors.New("generate target struct not found")
	}

	file := s.File()
	g.params.Package = file.Package()
	g.params.Imports = createImportParams(file.Imports())

	b, _ := ioutil.ReadFile(g.generatedFilePath())

	for _, gen := range g.gens {
		if err := gen.collectParams(aqi, b); err != nil {
			return err
		}
	}
	return nil
}

const combineTmplStr = `
// Code generated by structgen; DO NOT EDIT.

package {{ .Package }}

{{- if .Imports }}
import (
{{- range .Imports }}
	{{ .Name }} {{ .PathLiteral }}
{{- end }}
)
{{- end }}
`

var combineTmpl = template.Must(template.New("construct").Parse(combineTmplStr))

func (g *combineGenerator) generate() error {
	br := new(bytes.Buffer)
	if err := combineTmpl.Execute(br, g.params); err != nil {
		return errors.Wrap(err, "cannot execute template")
	}

	for _, gen := range g.gens {
		br.WriteString("\n\n")
		b, err := gen.generate()
		if err != nil {
			return err
		}
		br.Write(b)
	}

	b := br.Bytes()
	b, err := imports.Process("", b, nil)
	if err != nil {
		return errors.Wrap(err, "cannot format generated code")
	}

	if err := ioutil.WriteFile(g.generatedFilePath(), b, 0644); err != nil {
		return errors.Wrap(err, "cannot write generated code")
	}
	// format.Source(src []byte) ([]byte, error)
	return nil
}

type importParams struct {
	Name        string
	PathLiteral string
}

func createImportParams(imports aq.Imports) []importParams {
	r := []importParams{}
	for _, i := range imports {
		r = append(r, importParams{
			Name:        i.Name(),
			PathLiteral: fmt.Sprintf("%#v", i.Path()),
		})
	}

	return r
}

func getMarkedCode(code []byte, startMark string, endMark string) []byte {
	startIndex := bytes.Index(code, []byte(startMark))
	if startIndex == -1 {
		return nil
	}
	code = code[startIndex+len(startMark):]
	endIndex := bytes.Index(code, []byte(endMark))
	if startIndex == -1 {
		return nil
	}
	code = code[:endIndex]
	return code
}
